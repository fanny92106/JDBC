# Transaction


### 事务处理的原则: 
    保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提
    (commit), 那么这些修改就永久地保存下来；要么数据库管理系统放弃所做的所有修改，整个事务回滚(rollback)到最初状态。
    
    数据一旦提交 (commit)，就不可回滚
    
    
    
    
### ACID
    > 原子性 (Atomicity) -- 操作层面
        原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生
    > 一致性 (Consistency) -- 状态层面
        事务必须使数据库从一个一致性状态变换到另外一个一致性状态，不能有残留的中间状态
    > 隔离性 (Isolation) 
        一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能相互干扰
    > 持久性 (Durability) -- 结果层面
        一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响
    
    
    
    
### 哪些操作会导致数据的自动提交 (auto-commit), 以封装Transaction的逻辑
    > DDL 操作一旦执行，都会自动提交 (表的创建/删除，修改字段)
        > set autocommit = false 对 DDL 操作失效
    > DML 默认情况下，一旦执行，就会自动提交
        > 我们可以通过set autocommit = false 的方式取消 DML 操作的自动提交
    > 默认在关闭连接时，会自动提交数据
    
    
    
    
### 3个并发问题
    对于同时运行的多个事务，当这些事务访问数据库中的相同数据时，如果没有采取必要的隔离机制，就会导致各种并发问题: 
    > 脏读: 
        对于两个事务T1 T2, T1读取了已经被 T2 更新但还没有被提交的字段，之后若 T2 回滚，T1 读取的内容就是临时且无效的
    > 不可重复读:
        对于两个事务T1 T2, T1读取了一个字段，然后T2 !!!更新!!! 了该字段且提交，之后 T1 再次读取同一个字段，值就不同了
    > 幻读:
        对于两个事务T1 T2，T1 从一个表中读取了一个字段，然后 T2 在该表中又！！！插入!!!了一些新的行， 之后如果 T1 再次读取同一个表，就会多出几行



### 4个隔离级别
    > READ UNCOMMITTED (读未提交)：允许事务读取未被其他事务提交的变更
        解决的问题： x
    > READ COMMITED (读已提交数据): 只允许事务读取已经被其他事务提交的变更
        解决的问题: 脏读
    > REPEATABLE READ (可重复读): 确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事务对这个字段进行更新
        解决的问题: 脏读，不可重复读
    > SERIALIZABLE (串行化): 确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入，更新和删除操作，所有并发的问题都可以避免，但性能十分低下
        解决的问题: 脏读，不可重复读， 幻读
        
        
        
        
### DB的隔离级别设定
    > Oracle 支持2种事务隔离级别: READ COMMITED, SERIAALIZABLE, 默认是 READ COMMITED
    > MySQL 支持4种事务隔离级别: 默认是 REAPEATABLE READ
    
